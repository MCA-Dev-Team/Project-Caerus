echo -e """\nimport os\nimport platform\nimport subprocess\nimport random\nimport re\nimport time\nfrom threading import Thread\nclass Color:\n    PURPLE = '\\033[95m'\n    CYAN = '\\033[96m'\n    DARKCYAN = '\\033[36m'\n    BLUE = '\\033[94m'\n    GREEN = '\\033[92m'\n    YELLOW = '\\033[93m'\n    RED = '\\033[91m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'\n    END = '\\033[0m'\n    CWHITE = '\\33[37m'\nbanner_path = '/etc/ssh/banner'\nFileLockDownCommands = [\n    'chown root:shadow /etc/shadow && chmod 640 /etc/shadow',\n    'chown root:root /etc/group && chmod 644 /etc/group',\n    'chown root:shadow /etc/gshadow && chmod 640 /etc/gshadow',\n    'chown root:root /etc/security/opasswd && chmod 600 /etc/security/opasswd',\n    'chown root:root /etc/passwd- && chmod 600 /etc/passwd-',\n    'chown root:root /etc/shadow- && chmod 600 /etc/shadow-',\n    'chown root:root /etc/group- && chmod 600 /etc/group-',\n    'chown root:root /etc/gshadow- && chmod 600 /etc/gshadow-',\n    ''\n]\nArt='''\n   _             _             _\n  | |{}___________{}| |{}___________{}| |\n  | |{}___________{}| |{}___________{}| |\n  | |           | |           | |\n  | |           | |           | |\n  | |{}___________{}| |{}___________{}| |\n  | |{}___________{}| |{}___________{}| |\n  | |           | |           | |\n  | |           | |           | |\n  <<<<<<<<<<<{}Blue Screen{}>>>>>>>>>\n'''.format(Color.BLUE,Color.END,Color.BLUE,Color.END,Color.BLUE,Color.END,Color.BLUE,Color.END,Color.BLUE,Color.END,Color.BLUE,Color.END,Color.BLUE,Color.END,Color.BLUE,Color.END,Color.BLUE,Color.END)\nPasswords = ['Zeus', 'Athena', 'Apollo', 'Anubis', 'Medusa', 'Odin', 'Hercules', 'Aphrodite', 'Poseidon', 'Krishna',\n             'Ra', 'Shiva', 'Hades', 'Freyja', 'Persephone', 'Loki', 'Artemis', 'Osiris', 'Horus', 'Ganesh',\n             'Amaterasu', 'Fenrir', 'Hera', 'Kali', 'Baldur', 'Quetzalcoatl', 'Durga', 'Thor', 'Hestia', 'Gaea',\n             'Uranus', 'Pontus', 'Horus', 'Atlas', 'Oceanus', 'Cronus', 'Nyx', 'Zephyrus', 'Morpheus', 'Pallas',\n             'Pontus', 'Tartarus', 'Ares', 'Castor', 'Chaos', 'Crios', 'Dionysus', 'Helios', 'Hyperion', 'Hypnos']\n\ncharacters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*()_+'\nDefaultGateway = '192.168.1.1'\n\ndef main():\n    print(Art)\n    MyOS = platform.system()\n    Me = subprocess.Popen(['whoami'], shell=True, stdout=subprocess.PIPE).stdout.read()\n    WhoAmI = subprocess.Popen(['who am i'], shell=True, stdout=subprocess.PIPE).stdout.read()\n    default_gateway = next(line.split()[2] for line in (subprocess.Popen(['ip route'], shell=True,\n                                                                      stdout=subprocess.PIPE).stdout.read()).splitlines() if 'default' in line)\n    WhoAmI = WhoAmI.decode().strip().split()\n    username = WhoAmI[0]\n    terminal_line = WhoAmI[1]\n    login_time = ' '.join(WhoAmI[2:5])\n    ip_address = WhoAmI[5][1:-1]\n    print('''Detected: {}{}{}\\\\nRunning As: {}{}{}Username: {}{}{}\\\\nTerminal Line: {}{}{}\\\\nLogin Time: {}{}{}\\\\nIP Address: {}{}{}\\\\nDefault Gateway: {}{}{}'''.format(Color.CYAN, MyOS, Color.YELLOW, Color.GREEN, Me, Color.YELLOW, Color.GREEN,\n                                           username, Color.YELLOW, Color.PURPLE, terminal_line, Color.YELLOW, Color.PURPLE,\n                                           login_time, Color.YELLOW, Color.PURPLE, ip_address, Color.YELLOW, Color.BLUE,\n                                           default_gateway, Color.END))\n    #MENU\n    try:\n        while True:\n            Options=get_specific_input(int,'{}Choose from the Following options:{}\\\\n1 : Run Lockdown\\\\n2 : Configure Services\\\\n3 : Play Wack-a-Red-Teamer\\\\n0 : Run Internal Console{}\\\\n>>>'.format(Color.YELLOW,Color.CYAN,Color.END))\n            if Options==0:\n                try:\n                    while True:\n                        os.system(get_specific_input(str,'{}BlueScreen>>>{}'.format(Color.BLUE,Color.END)))\n                except KeyboardInterrupt:\n                    print('Returning to Main Menu')\n                \n            if Options==1:#Standard Lockdown\n                    command_thread = Thread(target=UpdateServices)\n                    command_thread.start()\n                    pkill_other_users(username,terminal_line,True)\n                    print('{}All Non-Freindlies {}Exterminated{}.'.format(Color.YELLOW,Color.RED,Color.END))\n                    password_reset()\n                    pkill_other_users(username,terminal_line,True)\n                    print('{}All Non-Freindlies {}Exterminated{}.'.format(Color.YELLOW,Color.RED,Color.END))\n                    lockdown_shadow_and_root()\n                    print('''{}etc/Shadow&Passwd&Group: {}Secured{}'''.format(Color.YELLOW,Color.GREEN, Color.END))\n                    banner_message = '''{}Hello {}Red Team{}, I sense your woe,\\\\nYet for {}Trevor's soul{}, I must go.\\\\nIn this battle's tide, I'll take control,\\\\nWhen I'm done, you'll pay the toll.{}\\\\n'''.format(Color.YELLOW,Color.RED,Color.YELLOW,Color.PURPLE,Color.YELLOW,Color.END)\n                    create_ssh_banner(banner_message, banner_path)\n                    update_ssh_config(banner_path,username)\n                    print('{}SSHd Config:{} Updated.{} Banner path: {}. Only {} can SSH.'.format(Color.YELLOW,Color.GREEN,Color.END,banner_path, Color.GREEN+username+Color.END))\n                    print('{}Services Update:{} Waiting for Update Thread'.format(Color.YELLOW,Color.END))\n                    print('{}Services Update:{} Update Complete{}'.format(Color.YELLOW, Color.GREEN,Color.END))\n                    config_firewall(ip_address,DefaultGateway,username)\n                    print('''IPv4 Firewall: {}Enabled{}'''.format(Color.GREEN, Color.END))\n                    Errors=Install_IpTables_Persist()\n                    if Errors:\n                        print('Errors occurred during update:')\n                        for error in Errors:\n                            print(Color.RED + 'Error: ' + Color.END + error)\n                        Errors=[]\n                    disable_ipv6()\n                    print('''IPv6: {}Disabled{}'''.format(Color.RED, Color.END))\n                    print('''IPv4 Firewall: {}Config Saved{}'''.format(Color.CYAN, Color.END))\n                    command_thread.join()\n                    if Errors:\n                        print('Errors occurred during update:')\n                        for error in Errors:\n                            print(Color.RED + 'Error: ' + Color.END + error)\n                        Errors=[]\n                    pkill_other_users(username,terminal_line,True)\n                    print('{}All Non-Freindlies {}Exterminated{}.'.format(Color.YELLOW,Color.RED,Color.END))\n            if Options==2:#Custom Config\n                try:\n                    while True:\n                        ConfigOptions=get_specific_input(int,'{}Choose from the Following options:{}\\\\n1 : Configure SSH\\\\n2 : Configure Firewall\\\\n3 : Lockdown Shadow and Root\\\\n4 : Update All Services\\\\n5 : Change all Passwords{}\\\\n>>>'.format(Color.YELLOW,Color.CYAN,Color.END))\n                        if ConfigOptions==1:\n                                create_ssh_banner(get_specific_input(str,'Enter New Banner: '),banner_path)\n                                update_ssh_config(banner_path,get_specific_input(str,'Enter allowed Users Seperated by ,: '))\n                        if ConfigOptions==2:\n                                config_firewall(ip_address,DefaultGateway,username)\n                                disable_ipv6()\n                                print('''IPv6: {}Disabled{}'''.format(Color.RED, Color.END))\n                                print('''IPv4 Firewall: {}Config Saved{}'''.format(Color.CYAN, Color.END))\n                        if ConfigOptions==3:\n                                lockdown_shadow_and_root()\n                        if ConfigOptions==4:\n                                UpdateServices()\n                        if ConfigOptions==5:\n                                password_reset()\n                        \n                            \n                except KeyboardInterrupt:\n                    print('Returning to Main Menu')\n            if Options==3:#Wack a Red Teamer\n                try:\n                    IHaveFriendlies=get_specific_input(bool_check,'I have Non-Friendlies on my account, true/false: ')\n                    print('{}Scanning For All {} Non-Friendlies{}.'.format(Color.YELLOW,Color.RED,Color.END))\n                    while True:\n                        #time.sleep(0.1)\n                        pkill_other_users(username,terminal_line,IHaveFriendlies)\n                except KeyboardInterrupt:\n                    print('Returning to Main Menu')\n            else:\n                print('Please Choose a valid option')\n    except KeyboardInterrupt:\n        print('Exiting BlueScreen')\n\ndef pkill_other_users(username, terminal_line, No_Friendlies):\n    while True:\n        Enemy=0\n        who_output = subprocess.Popen(['who'], stdout=subprocess.PIPE).communicate()[0].decode().split('\\\\n')\n        for line in who_output:\n            user_info = line.split()\n            if len(user_info) < 2:\n                continue\n            if username == user_info[0]:\n                if No_Friendlies:\n                    if user_info[1] == terminal_line:\n                        continue\n                    else:\n                        pass\n                else:\n                    continue\n                \n            Enemy+=1\n            BeGone=['<<< Exterminate! >>>','<<<Resistence Is Futile>>>','<<<We are the Borg. You will be assimilated. Resistance is futile.>>>','<<<Bite Me>>>']\n            message = random.choice(BeGone)\n            write_process = subprocess.Popen(['write', '{}'.format(user_info[0]),'{}'.format(user_info[1])], stdin=subprocess.PIPE)\n            write_process.communicate(input=message.encode())\n            subprocess.call(['pkill', '-t', user_info[1]])\n            print('{}Exterminated:{} User {} on {}'.format(Color.RED, Color.END, user_info[0], user_info[1]))\n        if Enemy==0:\n            break\n\n            \ndef Install_IpTables_Persist():\n    Errors=[]\n    # Suppress output of subprocesses and capture Errors\n    with open(os.devnull, 'w') as devnull:\n        try:\n            subprocess.check_call('echo \\'iptables-persistent iptables-persistent/autosave_v4 boolean true\\' |  debconf-set-selections', shell=True, stdout=devnull, stderr=subprocess.PIPE)\n        except subprocess.CalledProcessError as e:\n            Errors.append(str(e))\n\n        try:\n            subprocess.check_call('echo \\'iptables-persistent iptables-persistent/autosave_v6 boolean true\\' |  debconf-set-selections', shell=True, stdout=devnull, stderr=subprocess.PIPE)\n        except subprocess.CalledProcessError as e:\n            Errors.append(str(e))\n\n        try:\n            subprocess.check_call('apt-get install iptables-persistent -y', shell=True, stdout=devnull, stderr=subprocess.PIPE)\n        except subprocess.CalledProcessError as e:\n            Errors.append(str(e))\n    # Print any captured Errors\n        # Save the updated rules\n    with open('/etc/iptables/rules.v4', 'w') as rules_file:\n        subprocess.Popen(['iptables-save'], stdout=rules_file)\n    return Errors\ndef UpdateServices():\n    # Suppress output of subprocesses and capture Errors\n    Errors=[]\n    with open(os.devnull, 'w') as devnull:\n        try:\n            subprocess.check_call([ 'apt-get', 'update', '-y'], stdout=devnull, stderr=subprocess.PIPE)\n        except subprocess.CalledProcessError as e:\n            Errors.append(str(e))\n        try:\n            subprocess.check_call([ 'apt-get', 'update','--fix-missing','-y'], stdout=devnull, stderr=subprocess.PIPE)\n        except subprocess.CalledProcessError as e:\n            Errors.append(str(e))\n        try:\n            subprocess.check_call([ 'apt-get', 'upgrade', '-y'], stdout=devnull, stderr=subprocess.PIPE)\n        except subprocess.CalledProcessError as e:\n            Errors.append(str(e))\n    return Errors\n    \n\ndef deny_terminal_access_to_all_users():\n    passwd_file = '/etc/passwd'\n    passwd_backup_file = '/etc/passwd.backup'\n\n    # Check if the backup file exists, if not, create it\n    if not os.path.exists(passwd_backup_file):\n        with open(passwd_file, 'r') as src, open(passwd_backup_file, 'w') as dst:\n            dst.writelines(src.readlines())\n\n    # Read the contents of /etc/passwd\n    with open(passwd_file, 'r') as f:\n        lines = f.readlines()\n\n    # Modify the shell entry for each user to /bin/false if it's not already set\n    modified = False\n    for i, line in enumerate(lines):\n        parts = line.strip().split(':')\n        if parts[-1] != '/bin/false':\n            parts[-1] = '/bin/false'  # Change the shell to /bin/false\n            lines[i] = ':'.join(parts) + '\\\\n'\n            modified = True\n\n    # Write the modified contents back to /etc/passwd only if changes were made\n    if modified:\n        with open(passwd_file, 'w') as f:\n            f.writelines(lines)\n\n        print('{}Terminal Access:{} Denied for all users. {}#SuckItBob{}'.format(Color.YELLOW,Color.RED,Color.CYAN,Color.END))\n    else:\n        print('No changes needed. All users already have terminal access denied.')\ndef get_specific_input(data_type, custom_text):\n    while True:\n        try:\n            user_input = raw_input(custom_text)\n            data=data_type(user_input)\n            return data\n        except ValueError:\n            print('Please enter a valid {}\\!'.format(data_type.__name__))\ndef expand_ip_range(short_ip_range):\n    parts = short_ip_range.split('.')\n    expanded_parts = []\n\n    for part in parts:\n        if '-' in part:\n            start, end = map(int, part.split('-'))\n            expanded_part = (start, end)\n        else:\n            expanded_part = (int(part), int(part))\n        expanded_parts.append(expanded_part)\n\n    return expanded_parts\ndef password_reset():\n    passwd_output = subprocess.check_output(['cut', '-d:', '-f1', '/etc/passwd'])\n    users = passwd_output.split('\\\\n')\n    users.remove('')\n    for account in users:\n        new_password = random.choice(Passwords) + '_' + ''.join(random.choice(characters) for _ in range(6))\n        errormessage = subprocess.Popen(['passwd', account], stdin=subprocess.PIPE, stdout=subprocess.PIPE,\n                                         stderr=subprocess.PIPE, universal_newlines=True).communicate(\n            input=new_password + '\\\\n' + new_password + '\\\\n')\n        print('''User: {}{}{} \\\\n>>Password: {}{}{}''').format(Color.YELLOW, account, Color.END, Color.YELLOW,\n                                                               new_password, Color.END)\ndef bool_check(given):\n    return bool('true'==str(given))\ndef string_to_number_list(string_numbers):\n    return [int(x) for x in string_numbers.split(',')]\ndef config_firewall(MyIP,DefaultGateway,Username):\n    # Clear Current Rules\n    subprocess.call(['iptables', '-F'])  # Flush existing rules\n    #Preserve ME\n    subprocess.call('iptables -A INPUT -s {} -j ACCEPT'.format(MyIP), shell=True)\n    subprocess.call('iptables -A OUTPUT -d {} -j ACCEPT'.format(MyIP), shell=True)\n    print('{}Configure Firewall: {}Preserved Access of {}{}{}'.format(Color.YELLOW,Color.END,Color.GREEN,Username,Color.END))\n    subprocess.call(['iptables', '-P', 'INPUT', 'DROP'])\n    subprocess.call(['iptables', '-P', 'FORWARD', 'DROP'])\n    subprocess.call(['iptables', '-P', 'OUTPUT', 'DROP'])\n    print('{}Configure Firewall: {}Default IN-OUT set to Drop{}'.format(Color.YELLOW,Color.RED,Color.END))\n    DGports=get_specific_input(string_to_number_list,'{}Configure Firewall: {}Ports to allow from the default gateway. (Seperate with ,):'.format(Color.YELLOW,Color.END))\n    for Port in DGports:\n        subprocess.call('iptables -A INPUT -p tcp -s {} --dport {} -j ACCEPT'.format(DefaultGateway,Port), shell=True)\n        subprocess.call('iptables -A OUTPUT -p tcp -d {} --dport {} -j ACCEPT'.format(DefaultGateway,Port), shell=True)\n    print(('{}Default Gateway Allowed{}: {}'+', '.join(map(str, DGports))+'{}').format(Color.YELLOW,Color.END,Color.RED,Color.END))\n    # Install iptables-persistent and wait for it to finish\n    print('{}Installing{} IPTables-persistant{} to function as {}Sys-Firewall{}'.format(Color.YELLOW,Color.PURPLE,Color.END,Color.GREEN,Color.END))\n    #I'll make my own directories suck it bob\n    backup_dir = '/etc/iptables/'\n    if not os.path.exists(backup_dir):\n        os.makedirs(backup_dir)\n    #backup Existing Config\n    with open('/etc/iptables/rules.v4.backup', 'w') as backup_file:\n        subprocess.Popen(['iptables-save'], stdout=backup_file)\n\n    print('{}Configure Firewall: {} Allowed Ports{} and {}Ip\\'s{} that can connect to them:'.format(Color.YELLOW,Color.PURPLE,Color.END,Color.RED,Color.END))\n    while True:\n        Port=get_specific_input(int,'{}Port:{} Enter Port # or {}0{} when done:'.format(Color.YELLOW,Color.END,Color.RED,Color.END))\n        if(0 == Port):\n            break\n        UserIpInput=get_specific_input(str,'{}Port:{} {}{}{} Please enter Ips (Seperate with,):'.format(Color.YELLOW,Color.END,Color.RED,Port,Color.END))\n        IPaddress=UserIpInput.split(',')\n        if('all' in UserIpInput.lower()):\n            subprocess.call('iptables -A INPUT -p tcp --dport {} -j ACCEPT'.format(Port), shell=True)\n            subprocess.call('iptables -A OUTPUT -p tcp --dport {} -j ACCEPT'.format(Port), shell=True)  \n        elif(all(len(item.split('.')) == 4 for item in IPaddress)):\n            ConfiguredIps='{}Configured Allowed Ips on Port {}{}{}:'.format(Color.YELLOW,Color.GREEN,Port,Color.CYAN)\n            for IPaddress in IPaddress:\n                MinMaxIP=expand_ip_range(IPaddress)\n                MinIP=str(MinMaxIP[0][0])+'.'+str(MinMaxIP[1][0])+'.'+str(MinMaxIP[2][0])+'.'+str(MinMaxIP[3][0])\n                MaxIP=str(MinMaxIP[0][1])+'.'+str(MinMaxIP[1][1])+'.'+str(MinMaxIP[2][1])+'.'+str(MinMaxIP[3][1])\n                subprocess.call('iptables -A INPUT -p tcp --dport {} -m iprange --src-range {} -j ACCEPT'.format(Port,MinIP+'-'+MaxIP), shell=True)\n                subprocess.call('iptables -A OUTPUT -p tcp --sport {} -m iprange --src-range {} -j ACCEPT'.format(Port,MinIP+'-'+MaxIP), shell=True)\n                ConfiguredIps+='\\\\n'+MinIP+'-'+MaxIP\n            print(Color.END+ConfiguredIps)\n        else:\n            print('{}Configure Firewall:{} YO DUMASS, use a valid format next time:{}X.X.X.X,X.x-X.x-X.x-X{}'.format(Color.YELLOW,Color.END,Color.RED,Color.END))\n    print('Firewall rules configured successfully.')\n    \ndef disable_ipv6():\n    # Backup current IPv6 rules\n    subprocess.call('ip6tables-save > /etc/iptables/rules.v6.backup', shell=True)\n\n    # Set default policies\n    subprocess.call('ip6tables -P INPUT DROP', shell=True)\n    subprocess.call('ip6tables -P FORWARD DROP', shell=True)\n    subprocess.call('ip6tables -P OUTPUT DROP', shell=True)\n\n    # Save the updated rules\n    subprocess.call('ip6tables-save > /etc/iptables/rules.v6', shell=True)\n\ndef lockdown_shadow_and_root():\n    for command in FileLockDownCommands:\n        subprocess.Popen(command, shell=True)\ndef backup_config(file_path):\n    subprocess.Popen(['cp', file_path, file_path + '.backup'])\n\ndef create_ssh_banner(message, banner_path):\n    with open(banner_path, 'w') as f:\n        f.write(message)\n    print('{}SSHd Config:{} Banner created at: {}'.format(Color.YELLOW,Color.END,banner_path))\n\ndef update_ssh_config(banner_path, allowed_user):\n    sshd_config_path = '/etc/ssh/sshd_config'\n    sshd_config_backup_path = '/etc/ssh/sshd_config.backup'\n\n    try:\n        # Backup the original sshd_config file\n        os.rename(sshd_config_path, sshd_config_backup_path)\n\n        # Read the entire content of the original sshd_config file\n        with open(sshd_config_backup_path, 'r') as f_in:\n            config_content = f_in.read()\n\n        # Check if AllowUsers already exists in the configuration\n        allow_users_match = re.search(r'^\\s*#?\\s*AllowUsers.*$', config_content, flags=re.MULTILINE)\n        \n        if allow_users_match:\n            # If AllowUsers exists, modify it\n            config_content = re.sub(allow_users_match.group(), 'AllowUsers {}'.format(allowed_user), config_content)\n        else:\n            # If AllowUsers does not exist, add it to the configuration\n            config_content += '\\\\nAllowUsers {}\\\\n'.format(allowed_user)\n\n        # Replace or add Banner configuration\n        config_content = re.sub(r'^\\s*#?\\s*Banner.*$', 'Banner {}'.format(banner_path), config_content, flags=re.MULTILINE)\n\n        # Write the modified content back to the sshd_config file\n        with open(sshd_config_path, 'w') as f_out:\n            f_out.write(config_content)\n\n        # Change ownership and permissions\n        #subprocess.call(['chown', 'root:root', sshd_config_path])\n        #subprocess.call(['chmod', '600', sshd_config_path])\n        \n        # Restart SSH service\n        subprocess.call([ 'systemctl', 'restart', 'ssh'])\n\n    except Exception as e:\n        # Restore original sshd_config in case of error\n        os.rename(sshd_config_backup_path, sshd_config_path)\n        print('An error occurred: {}'.format(e))\n\nif __name__ == '__main__':\n    main()\n""" > BlueScreen.py;python BlueScreen.py